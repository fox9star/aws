<!doctype html>
<html lang="ko" class="h-full">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ë–¨ì–´ì§€ëŠ” ëª¨í—˜</title>
  <script src="/_sdk/element_sdk.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
        body {
            box-sizing: border-box;
        }
        
        #gameCanvas {
            border: 3px solid #4f46e5;
            border-radius: 12px;
            background: linear-gradient(180deg, #ffffff 0%, #98fb98 100%);
        }
        
        .game-button {
            transition: all 0.2s ease;
        }
        
        .game-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        
        .score-display {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
        }
    </style>
  <style>@view-transition { navigation: auto; }</style>
  <script src="/_sdk/data_sdk.js" type="text/javascript"></script>
 </head>
 <body class="h-full bg-gradient-to-br from-purple-100 to-pink-100 flex items-center justify-center p-4">
  <main class="bg-white rounded-2xl shadow-xl p-6 w-full max-w-lg">
   <header class="text-center mb-6">
    <h1 id="game-title" class="text-3xl font-bold text-gray-800 mb-2">ë–¨ì–´ì§€ëŠ” ëª¨í—˜</h1>
    <p class="text-gray-600">ì¢Œìš° í™”ì‚´í‘œ í‚¤ë¡œ ìºë¦­í„°ë¥¼ ì¡°ì‘í•˜ì„¸ìš”!</p><!-- ìºë¦­í„° ê°œìˆ˜ ì„¤ì • -->
    <div id="characterSettings" class="mt-4 bg-gray-50 rounded-lg p-4"><label class="block text-sm font-medium text-gray-700 mb-2">ìºë¦­í„° ê°œìˆ˜</label> <input type="number" id="characterCount" min="1" max="100" value="1" class="w-24 text-center border-2 border-gray-200 rounded-lg py-1 px-2 focus:border-blue-500 focus:outline-none">
     <p class="text-xs text-gray-500 mt-1">1-100ê°œ ì‚¬ì´ë¡œ ì„¤ì •í•˜ì„¸ìš”</p>
    </div>
   </header>
   <div class="relative">
    <canvas id="gameCanvas" width="400" height="500" class="w-full"></canvas><!-- ê²Œì„ ì˜¤ë²„ë ˆì´ -->
    <div id="gameOverlay" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50 rounded-xl">
     <div class="bg-white rounded-lg p-6 text-center">
      <div id="gameMessage" class="text-xl font-bold text-gray-800 mb-4">
       ê²Œì„ì„ ì‹œì‘í•˜ì„¸ìš”!
      </div><button id="gameButton" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-3 px-6 rounded-lg game-button"> <span id="button-text">ê²Œì„ ì‹œì‘</span> </button>
     </div>
    </div><!-- ìˆœìœ„ í‘œì‹œ -->
    <div id="rankingDisplay" class="absolute top-4 left-4 score-display rounded-lg px-3 py-2 hidden">
     <div class="text-sm font-semibold text-gray-800">
      ì™„ì£¼: <span id="finishedCount">0</span>/<span id="totalCount">1</span>
     </div>
     <div class="text-xs text-gray-600">
      ê²½ì£¼ ì§„í–‰ì¤‘...
     </div>
    </div><!-- ì‹¤ì‹œê°„ ìˆœìœ„ ëª©ë¡ -->
    <div id="liveRanking" class="absolute top-4 left-4 bg-white bg-opacity-95 rounded-lg p-3 shadow-lg hidden max-h-96 overflow-y-auto" style="width: 200px;">
     <div class="text-sm font-bold text-gray-800 mb-2 text-center">
      ğŸ† ê³¨ì¸ ìˆœìœ„
     </div>
     <div id="rankingList" class="space-y-1"><!-- ìˆœìœ„ê°€ ì—¬ê¸°ì— ë™ì ìœ¼ë¡œ ì¶”ê°€ë©ë‹ˆë‹¤ -->
     </div>
    </div>
   </div>
   <div class="mt-4 text-center text-sm text-gray-600">
    <p>ğŸ ëª©í‘œ: ì¥ì• ë¬¼ì„ í”¼í•´ ê°€ì¥ ë¨¼ì € ë°”ë‹¥ì— ë„ì°©í•˜ì„¸ìš”!</p>
   </div>
  </main>
  <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameOverlay = document.getElementById('gameOverlay');
        const gameMessage = document.getElementById('gameMessage');
        const gameButton = document.getElementById('gameButton');
        const rankingDisplay = document.getElementById('rankingDisplay');
        const finishedCountElement = document.getElementById('finishedCount');
        const totalCountElement = document.getElementById('totalCount');
        const liveRanking = document.getElementById('liveRanking');
        const rankingList = document.getElementById('rankingList');

        const defaultConfig = {
            game_title: "ë–¨ì–´ì§€ëŠ” ëª¨í—˜",
            start_button_text: "ê²Œì„ ì‹œì‘",
            restart_button_text: "ë‹¤ì‹œí•˜ê¸°"
        };

        let gameState = 'menu'; // 'menu', 'playing', 'gameOver', 'win'
        let animationId;
        
        // ê²Œì„ ê°ì²´ë“¤
        let players = [];
        const playerColors = [
            '#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#f0932b',
            '#6c5ce7', '#fd79a8', '#00b894', '#e17055', '#74b9ff',
            '#a29bfe', '#fd79a8', '#fdcb6e', '#e84393', '#00cec9',
            '#55a3ff', '#ff7675', '#81ecec', '#fab1a0', '#00b894'
        ];

        const obstacles = [];
        const particles = [];
        let camera = { y: 0 };
        let finishOrder = [];
        let gameStartTime = 0;
        const FINISH_LINE_Y = 2500; // ë°”ë‹¥ ìœ„ì¹˜
        
        // í‚¤ ì…ë ¥ ìƒíƒœ
        const keys = {
            left: false,
            right: false
        };

        // ìºë¦­í„° ìƒì„± í•¨ìˆ˜
        function createPlayers(count) {
            players = [];
            const cols = Math.ceil(Math.sqrt(count));
            const rows = Math.ceil(count / cols);
            const spacing = Math.min(40, canvas.width / (cols + 1));
            
            for (let i = 0; i < count; i++) {
                const row = Math.floor(i / cols);
                const col = i % cols;
                const x = (canvas.width / (cols + 1)) * (col + 1) - 15;
                const y = 50 + row * 40;
                
                players.push({
                    x: x,
                    y: y,
                    width: 30,
                    height: 30,
                    vx: 0,
                    vy: 1,
                    color: playerColors[i % playerColors.length],
                    alive: true,
                    id: i + 1,
                    name: `ìºë¦­í„° ${i + 1}`,
                    finished: false,
                    finishTime: null
                });
            }
        }

        // ì¥ì• ë¬¼ ìƒì„± (ëœë¤ ë°°ì¹˜, í†µë¡œ ë³´ì¥)
        function createObstacle(y) {
            const numObstacles = Math.floor(Math.random() * 2) + 1; // 1-2ê°œ ì¥ì• ë¬¼ë¡œ ì¤„ì„
            const minGap = 80; // ìµœì†Œ í†µë¡œ ë„ˆë¹„
            
            for (let i = 0; i < numObstacles; i++) {
                const obstacleWidth = 30 + Math.random() * 60; // 30-90 ë„ˆë¹„ (ë” ì‘ê²Œ)
                const obstacleHeight = 15 + Math.random() * 20; // 15-35 ë†’ì´
                
                // í†µë¡œë¥¼ ë³´ì¥í•˜ê¸° ìœ„í•œ ìœ„ì¹˜ ê³„ì‚°
                let x;
                if (numObstacles === 1) {
                    // ì¥ì• ë¬¼ì´ 1ê°œë©´ ì–‘ìª½ì— ì¶©ë¶„í•œ ê³µê°„ í™•ë³´
                    const maxX = canvas.width - obstacleWidth - minGap/2;
                    const minX = minGap/2;
                    x = minX + Math.random() * (maxX - minX);
                } else {
                    // ì¥ì• ë¬¼ì´ 2ê°œë©´ ê°€ìš´ë° í†µë¡œ í™•ë³´
                    if (i === 0) {
                        x = Math.random() * (canvas.width/2 - obstacleWidth - minGap/2);
                    } else {
                        x = canvas.width/2 + minGap/2 + Math.random() * (canvas.width/2 - obstacleWidth - minGap/2);
                    }
                }
                
                const tiltAngle = (Math.random() - 0.5) * 0.8; // ê¸°ìš¸ê¸° ì¤„ì„
                
                obstacles.push({
                    x: x,
                    y: y + i * 25,
                    width: obstacleWidth,
                    height: obstacleHeight,
                    tilt: tiltAngle,
                    color: '#8b5cf6',
                    type: 'tilted'
                });
            }
        }

        // íŒŒí‹°í´ ìƒì„±
        function createParticles(x, y, color) {
            for (let i = 0; i < 8; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    life: 30,
                    maxLife: 30,
                    color: color
                });
            }
        }

        // ì‹¤ì‹œê°„ ìˆœìœ„ ëª©ë¡ ì—…ë°ì´íŠ¸
        function updateRankingList() {
            rankingList.innerHTML = '';
            
            finishOrder.forEach((result, index) => {
                const rankItem = document.createElement('div');
                rankItem.className = 'flex items-center justify-between text-xs py-1 px-2 rounded';
                
                // ìˆœìœ„ë³„ ë°°ê²½ìƒ‰
                if (result.rank === 1) {
                    rankItem.className += ' bg-yellow-100 border border-yellow-300';
                } else if (result.rank === 2) {
                    rankItem.className += ' bg-gray-100 border border-gray-300';
                } else if (result.rank === 3) {
                    rankItem.className += ' bg-orange-100 border border-orange-300';
                } else {
                    rankItem.className += ' bg-blue-50 border border-blue-200';
                }
                
                const medal = result.rank === 1 ? 'ğŸ¥‡' : result.rank === 2 ? 'ğŸ¥ˆ' : result.rank === 3 ? 'ğŸ¥‰' : 'ğŸƒ';
                
                rankItem.innerHTML = `
                    <div class="flex items-center">
                        <span class="mr-1">${medal}</span>
                        <span class="font-semibold">${result.rank}ìœ„</span>
                    </div>
                    <div class="text-right">
                        <div class="font-medium">ìºë¦­í„° ${result.id}</div>
                        <div class="text-gray-600">${(result.time/1000).toFixed(1)}ì´ˆ</div>
                    </div>
                `;
                
                rankingList.appendChild(rankItem);
            });
        }

        // ì¶©ëŒ ê°ì§€
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        // ì¥ì• ë¬¼ê³¼ ì¶©ëŒ ì²˜ë¦¬
        function handleObstacleCollision(player, obstacle) {
            // ì¶©ëŒ ë°©í–¥ ê³„ì‚°
            const playerCenterX = player.x + player.width / 2;
            const playerCenterY = player.y + player.height / 2;
            const obstacleCenterX = obstacle.x + obstacle.width / 2;
            const obstacleCenterY = obstacle.y + obstacle.height / 2;
            
            const dx = playerCenterX - obstacleCenterX;
            const dy = playerCenterY - obstacleCenterY;
            
            // íŠ•ê¸°ëŠ” í˜ ì ìš©
            const bounceForce = 1.5;
            player.vx += (dx / Math.abs(dx || 1)) * bounceForce;
            player.vy -= bounceForce;
            
            // ì†ë„ ì œí•œ
            player.vx = Math.max(-4, Math.min(4, player.vx));
            player.vy = Math.max(-3, player.vy);
        }

        // ê²Œì„ ì´ˆê¸°í™”
        function initGame() {
            const characterCount = parseInt(document.getElementById('characterCount').value) || 1;
            createPlayers(characterCount);
            obstacles.length = 0;
            particles.length = 0;
            camera.y = 0;
            finishOrder = [];
            gameStartTime = Date.now();
            
            // UI ì—…ë°ì´íŠ¸
            totalCountElement.textContent = characterCount;
            finishedCountElement.textContent = '0';
            
            // ì¥ì• ë¬¼ ìƒì„± (ë°”ë‹¥ê¹Œì§€ì˜ ê²½ë¡œ)
            for (let i = 0; i < 30; i++) {
                createObstacle(150 + i * 80);
            }
        }

        // ê²Œì„ ì—…ë°ì´íŠ¸
        function updateGame() {
            if (gameState !== 'playing') return;
            
            let alivePlayers = players.filter(p => p.alive);
            
            // ëª¨ë“  ì‚´ì•„ìˆëŠ” í”Œë ˆì´ì–´ ì—…ë°ì´íŠ¸
            for (let player of alivePlayers) {
                // í”Œë ˆì´ì–´ ì´ë™
                if (keys.left) player.vx = Math.max(player.vx - 0.25, -2.5);
                if (keys.right) player.vx = Math.min(player.vx + 0.25, 2.5);
                
                // ì¤‘ë ¥ ì ìš©
                player.vy += 0.1;
                
                // ë§ˆì°°ë ¥
                player.vx *= 0.95;
                
                // í”Œë ˆì´ì–´ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                player.x += player.vx;
                player.y += player.vy;
                
                // í™”ë©´ ê²½ê³„ ì²˜ë¦¬
                if (player.x < 0) player.x = 0;
                if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
                
                // ì¥ì• ë¬¼ê³¼ ì¶©ëŒ ê²€ì‚¬
                for (let obstacle of obstacles) {
                    if (checkCollision(player, obstacle)) {
                        handleObstacleCollision(player, obstacle);
                        createParticles(player.x + player.width/2, player.y + player.height/2, player.color);
                    }
                }
                
                // ê³¨ì¸ ì²´í¬ (ë°”ë‹¥ì— ë„ì°©)
                if (player.y >= FINISH_LINE_Y && !player.finished) {
                    player.finished = true;
                    player.finishTime = Date.now() - gameStartTime;
                    finishOrder.push({
                        rank: finishOrder.length + 1,
                        name: player.name,
                        id: player.id,
                        time: player.finishTime
                    });
                    createParticles(player.x + player.width/2, player.y + player.height/2, '#4ade80');
                    
                    // UI ì—…ë°ì´íŠ¸
                    finishedCountElement.textContent = finishOrder.length;
                    updateRankingList();
                }
            }
            
            // ì¹´ë©”ë¼ ì—…ë°ì´íŠ¸ (ê°€ì¥ ì•ì„  ìºë¦­í„° ê¸°ì¤€)
            let frontPlayer = alivePlayers.reduce((front, current) => 
                current.y > front.y ? current : front, alivePlayers[0]);
            camera.y = frontPlayer.y - 200;
            
            // ìŠ¹ë¦¬ ì¡°ê±´ (ëª¨ë“  ìºë¦­í„°ê°€ ê³¨ì¸)
            if (finishOrder.length === players.length) {
                gameState = 'win';
                let resultText = `ğŸ ê²½ì£¼ ì™„ë£Œ!\n\nğŸ† ìµœì¢… ìˆœìœ„:\n`;
                finishOrder.forEach(result => {
                    const medal = result.rank === 1 ? 'ğŸ¥‡' : result.rank === 2 ? 'ğŸ¥ˆ' : result.rank === 3 ? 'ğŸ¥‰' : 'ğŸƒ';
                    resultText += `${medal} ${result.rank}ìœ„: ${result.name} (${(result.time/1000).toFixed(1)}ì´ˆ)\n`;
                });
                gameMessage.innerHTML = resultText.replace(/\n/g, '<br>');
                gameOverlay.classList.remove('hidden');
                rankingDisplay.classList.add('hidden');
                showGameOver();
                return;
            }
            
            // íŒŒí‹°í´ ì—…ë°ì´íŠ¸
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vy += 0.1; // ì¤‘ë ¥
                particle.life--;
                
                if (particle.life <= 0) {
                    particles.splice(i, 1);
                }
            }
            

        }

        // ê²Œì„ ë Œë”ë§
        function renderGame() {
            // ë°°ê²½ í´ë¦¬ì–´
            ctx.fillStyle = '#87ceeb';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // êµ¬ë¦„ íš¨ê³¼
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            for (let i = 0; i < 5; i++) {
                const cloudY = 100 + i * 80 - camera.y;
                if (cloudY > -50 && cloudY < canvas.height + 50) {
                    ctx.beginPath();
                    ctx.arc(50 + i * 80, cloudY, 25, 0, Math.PI * 2);
                    ctx.arc(80 + i * 80, cloudY, 35, 0, Math.PI * 2);
                    ctx.arc(110 + i * 80, cloudY, 25, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // ë°”ë‹¥ ë Œë”ë§
            const floorY = FINISH_LINE_Y - camera.y;
            if (floorY > -100 && floorY < canvas.height + 100) {
                // ë°”ë‹¥ ê·¸ë¼ë””ì–¸íŠ¸
                const floorGradient = ctx.createLinearGradient(0, floorY - 20, 0, floorY + 50);
                floorGradient.addColorStop(0, '#8B4513');
                floorGradient.addColorStop(0.3, '#A0522D');
                floorGradient.addColorStop(1, '#654321');
                
                ctx.fillStyle = floorGradient;
                ctx.fillRect(0, floorY, canvas.width, 100);
                
                // ê³¨ì¸ì„ 
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(0, floorY - 5, canvas.width, 10);
                
                // ì²´í¬ë¬´ëŠ¬ íŒ¨í„´
                ctx.fillStyle = '#000000';
                for (let i = 0; i < canvas.width; i += 20) {
                    if (Math.floor(i / 20) % 2 === 0) {
                        ctx.fillRect(i, floorY - 5, 10, 10);
                    } else {
                        ctx.fillRect(i + 10, floorY + 5, 10, 10);
                    }
                }
                
                // ê³¨ì¸ í…ìŠ¤íŠ¸
                ctx.fillStyle = '#ffffff';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 3;
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.strokeText('ğŸ FINISH LINE ğŸ', canvas.width/2, floorY - 15);
                ctx.fillText('ğŸ FINISH LINE ğŸ', canvas.width/2, floorY - 15);
            }
            
            // ì¥ì• ë¬¼ ë Œë”ë§ (ê¸°ìš¸ì–´ì§„ í˜•íƒœ)
            for (let obstacle of obstacles) {
                const obstacleY = obstacle.y - camera.y;
                if (obstacleY > -50 && obstacleY < canvas.height + 50) {
                    ctx.save();
                    
                    if (obstacle.type === 'tilted') {
                        // ê¸°ìš¸ì–´ì§„ ì¥ì• ë¬¼ ë Œë”ë§
                        const centerX = obstacle.x + obstacle.width / 2;
                        const centerY = obstacleY + obstacle.height / 2;
                        
                        ctx.translate(centerX, centerY);
                        ctx.rotate(obstacle.tilt);
                        
                        // ì¥ì• ë¬¼ ë³¸ì²´
                        ctx.fillStyle = obstacle.color;
                        ctx.fillRect(-obstacle.width/2, -obstacle.height/2, obstacle.width, obstacle.height);
                        
                        // ì¥ì• ë¬¼ í•˜ì´ë¼ì´íŠ¸
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.fillRect(-obstacle.width/2, -obstacle.height/2, obstacle.width, 5);
                        
                        // ê·¸ë¼ë””ì–¸íŠ¸ íš¨ê³¼
                        const gradient = ctx.createLinearGradient(-obstacle.width/2, -obstacle.height/2, -obstacle.width/2, obstacle.height/2);
                        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.2)');
                        gradient.addColorStop(1, 'rgba(0, 0, 0, 0.2)');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(-obstacle.width/2, -obstacle.height/2, obstacle.width, obstacle.height);
                    } else {
                        // ì¼ë°˜ ì¥ì• ë¬¼
                        ctx.fillStyle = obstacle.color;
                        ctx.fillRect(obstacle.x, obstacleY, obstacle.width, obstacle.height);
                        
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.fillRect(obstacle.x, obstacleY, obstacle.width, 5);
                    }
                    
                    ctx.restore();
                }
            }
            
            // í”Œë ˆì´ì–´ë“¤ ë Œë”ë§ (ê·€ì—¬ìš´ ìºë¦­í„°ë“¤)
            for (let player of players) {
                if (!player.alive) continue;
                
                const playerScreenY = player.y - camera.y;
                
                // í™”ë©´ì— ë³´ì´ëŠ” ìºë¦­í„°ë§Œ ë Œë”ë§
                if (playerScreenY < -50 || playerScreenY > canvas.height + 50) continue;
                
                // ê·¸ë¦¼ì
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.beginPath();
                ctx.ellipse(player.x + player.width/2, playerScreenY + player.height + 5, player.width/2, 5, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // ìºë¦­í„° ëª¸ì²´
                ctx.fillStyle = player.color;
                ctx.beginPath();
                ctx.arc(player.x + player.width/2, playerScreenY + player.height/2, player.width/2, 0, Math.PI * 2);
                ctx.fill();
                
                // ëˆˆ
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(player.x + 8, playerScreenY + 8, 4, 0, Math.PI * 2);
                ctx.arc(player.x + 22, playerScreenY + 8, 4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(player.x + 8, playerScreenY + 8, 2, 0, Math.PI * 2);
                ctx.arc(player.x + 22, playerScreenY + 8, 2, 0, Math.PI * 2);
                ctx.fill();
                
                // ì…
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(player.x + player.width/2, playerScreenY + 18, 6, 0, Math.PI);
                ctx.stroke();
                
                // ìºë¦­í„° ë²ˆí˜¸ í‘œì‹œ
                ctx.fillStyle = '#ffffff';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.strokeText(player.id.toString(), player.x + player.width/2, playerScreenY - 5);
                ctx.fillText(player.id.toString(), player.x + player.width/2, playerScreenY - 5);
            }
            
            // íŒŒí‹°í´ ë Œë”ë§
            for (let particle of particles) {
                const particleScreenY = particle.y - camera.y;
                const alpha = particle.life / particle.maxLife;
                ctx.fillStyle = particle.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                ctx.beginPath();
                ctx.arc(particle.x, particleScreenY, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // ê²Œì„ ë£¨í”„
        function gameLoop() {
            updateGame();
            renderGame();
            animationId = requestAnimationFrame(gameLoop);
        }

        // ê²Œì„ ì‹œì‘
        function startGame() {
            initGame();
            gameState = 'playing';
            gameOverlay.classList.add('hidden');
            rankingDisplay.classList.add('hidden');
            liveRanking.classList.remove('hidden');
            document.getElementById('characterSettings').style.display = 'none';
            updateRankingList(); // ë¹ˆ ëª©ë¡ìœ¼ë¡œ ì´ˆê¸°í™”
            gameLoop();
        }

        // ê²Œì„ ì¢…ë£Œ ì‹œ ì„¤ì • ë‹¤ì‹œ ë³´ì´ê¸°
        function showGameOver() {
            document.getElementById('characterSettings').style.display = 'block';
            liveRanking.classList.add('hidden');
        }

        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        gameButton.addEventListener('click', startGame);

        document.addEventListener('keydown', (e) => {
            if (e.code === 'ArrowLeft') {
                keys.left = true;
                e.preventDefault();
            }
            if (e.code === 'ArrowRight') {
                keys.right = true;
                e.preventDefault();
            }
            if (e.code === 'Space' && gameState !== 'playing') {
                startGame();
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'ArrowLeft') keys.left = false;
            if (e.code === 'ArrowRight') keys.right = false;
        });

        // Element SDK ì„¤ì •
        async function render(config) {
            const gameTitle = document.getElementById('game-title');
            const buttonText = document.getElementById('button-text');
            
            gameTitle.textContent = config.game_title || defaultConfig.game_title;
            
            if (gameState === 'menu') {
                buttonText.textContent = config.start_button_text || defaultConfig.start_button_text;
            } else {
                buttonText.textContent = config.restart_button_text || defaultConfig.restart_button_text;
            }
        }

        function mapToCapabilities(config) {
            return {
                recolorables: [],
                borderables: [],
                fontEditable: undefined,
                fontSizeable: undefined
            };
        }

        function mapToEditPanelValues(config) {
            return new Map([
                ["game_title", config.game_title || defaultConfig.game_title],
                ["start_button_text", config.start_button_text || defaultConfig.start_button_text],
                ["restart_button_text", config.restart_button_text || defaultConfig.restart_button_text]
            ]);
        }

        // SDK ì´ˆê¸°í™”
        if (window.elementSdk) {
            window.elementSdk.init({
                defaultConfig,
                render,
                mapToCapabilities,
                mapToEditPanelValues
            });
        }

        // ì´ˆê¸° ë Œë”ë§
        renderGame();
    </script>
 <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'990eb5f9548fe9fc',t:'MTc2MDg2MDUwMi4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>