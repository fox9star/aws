<!doctype html>
<html lang="ko" class="h-full">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>떨어지는 모험</title>
  <script src="/_sdk/element_sdk.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
        body {
            box-sizing: border-box;
        }
        
        #gameCanvas {
            border: 3px solid #4f46e5;
            border-radius: 12px;
            background: linear-gradient(180deg, #ffffff 0%, #98fb98 100%);
        }
        
        .game-button {
            transition: all 0.2s ease;
        }
        
        .game-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        
        .score-display {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
        }
    </style>
  <style>@view-transition { navigation: auto; }</style>
  <script src="/_sdk/data_sdk.js" type="text/javascript"></script>
 </head>
 <body class="h-full bg-gradient-to-br from-purple-100 to-pink-100 flex items-center justify-center p-4">
  <main class="bg-white rounded-2xl shadow-xl p-6 w-full max-w-lg">
   <header class="text-center mb-6">
    <h1 id="game-title" class="text-3xl font-bold text-gray-800 mb-2">떨어지는 모험</h1>
    <p class="text-gray-600">좌우 화살표 키로 캐릭터를 조작하세요!</p><!-- 캐릭터 개수 설정 -->
    <div id="characterSettings" class="mt-4 bg-gray-50 rounded-lg p-4"><label class="block text-sm font-medium text-gray-700 mb-2">캐릭터 개수</label> <input type="number" id="characterCount" min="1" max="100" value="1" class="w-24 text-center border-2 border-gray-200 rounded-lg py-1 px-2 focus:border-blue-500 focus:outline-none">
     <p class="text-xs text-gray-500 mt-1">1-100개 사이로 설정하세요</p>
    </div>
   </header>
   <div class="relative">
    <canvas id="gameCanvas" width="400" height="500" class="w-full"></canvas><!-- 게임 오버레이 -->
    <div id="gameOverlay" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50 rounded-xl">
     <div class="bg-white rounded-lg p-6 text-center">
      <div id="gameMessage" class="text-xl font-bold text-gray-800 mb-4">
       게임을 시작하세요!
      </div><button id="gameButton" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-3 px-6 rounded-lg game-button"> <span id="button-text">게임 시작</span> </button>
     </div>
    </div><!-- 순위 표시 -->
    <div id="rankingDisplay" class="absolute top-4 left-4 score-display rounded-lg px-3 py-2 hidden">
     <div class="text-sm font-semibold text-gray-800">
      완주: <span id="finishedCount">0</span>/<span id="totalCount">1</span>
     </div>
     <div class="text-xs text-gray-600">
      경주 진행중...
     </div>
    </div><!-- 실시간 순위 목록 -->
    <div id="liveRanking" class="absolute top-4 left-4 bg-white bg-opacity-95 rounded-lg p-3 shadow-lg hidden max-h-96 overflow-y-auto" style="width: 200px;">
     <div class="text-sm font-bold text-gray-800 mb-2 text-center">
      🏆 골인 순위
     </div>
     <div id="rankingList" class="space-y-1"><!-- 순위가 여기에 동적으로 추가됩니다 -->
     </div>
    </div>
   </div>
   <div class="mt-4 text-center text-sm text-gray-600">
    <p>🏁 목표: 장애물을 피해 가장 먼저 바닥에 도착하세요!</p>
   </div>
  </main>
  <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameOverlay = document.getElementById('gameOverlay');
        const gameMessage = document.getElementById('gameMessage');
        const gameButton = document.getElementById('gameButton');
        const rankingDisplay = document.getElementById('rankingDisplay');
        const finishedCountElement = document.getElementById('finishedCount');
        const totalCountElement = document.getElementById('totalCount');
        const liveRanking = document.getElementById('liveRanking');
        const rankingList = document.getElementById('rankingList');

        const defaultConfig = {
            game_title: "떨어지는 모험",
            start_button_text: "게임 시작",
            restart_button_text: "다시하기"
        };

        let gameState = 'menu'; // 'menu', 'playing', 'gameOver', 'win'
        let animationId;
        
        // 게임 객체들
        let players = [];
        const playerColors = [
            '#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#f0932b',
            '#6c5ce7', '#fd79a8', '#00b894', '#e17055', '#74b9ff',
            '#a29bfe', '#fd79a8', '#fdcb6e', '#e84393', '#00cec9',
            '#55a3ff', '#ff7675', '#81ecec', '#fab1a0', '#00b894'
        ];

        const obstacles = [];
        const particles = [];
        let camera = { y: 0 };
        let finishOrder = [];
        let gameStartTime = 0;
        const FINISH_LINE_Y = 2500; // 바닥 위치
        
        // 키 입력 상태
        const keys = {
            left: false,
            right: false
        };

        // 캐릭터 생성 함수
        function createPlayers(count) {
            players = [];
            const cols = Math.ceil(Math.sqrt(count));
            const rows = Math.ceil(count / cols);
            const spacing = Math.min(40, canvas.width / (cols + 1));
            
            for (let i = 0; i < count; i++) {
                const row = Math.floor(i / cols);
                const col = i % cols;
                const x = (canvas.width / (cols + 1)) * (col + 1) - 15;
                const y = 50 + row * 40;
                
                players.push({
                    x: x,
                    y: y,
                    width: 30,
                    height: 30,
                    vx: 0,
                    vy: 1,
                    color: playerColors[i % playerColors.length],
                    alive: true,
                    id: i + 1,
                    name: `캐릭터 ${i + 1}`,
                    finished: false,
                    finishTime: null
                });
            }
        }

        // 장애물 생성 (랜덤 배치, 통로 보장)
        function createObstacle(y) {
            const numObstacles = Math.floor(Math.random() * 2) + 1; // 1-2개 장애물로 줄임
            const minGap = 80; // 최소 통로 너비
            
            for (let i = 0; i < numObstacles; i++) {
                const obstacleWidth = 30 + Math.random() * 60; // 30-90 너비 (더 작게)
                const obstacleHeight = 15 + Math.random() * 20; // 15-35 높이
                
                // 통로를 보장하기 위한 위치 계산
                let x;
                if (numObstacles === 1) {
                    // 장애물이 1개면 양쪽에 충분한 공간 확보
                    const maxX = canvas.width - obstacleWidth - minGap/2;
                    const minX = minGap/2;
                    x = minX + Math.random() * (maxX - minX);
                } else {
                    // 장애물이 2개면 가운데 통로 확보
                    if (i === 0) {
                        x = Math.random() * (canvas.width/2 - obstacleWidth - minGap/2);
                    } else {
                        x = canvas.width/2 + minGap/2 + Math.random() * (canvas.width/2 - obstacleWidth - minGap/2);
                    }
                }
                
                const tiltAngle = (Math.random() - 0.5) * 0.8; // 기울기 줄임
                
                obstacles.push({
                    x: x,
                    y: y + i * 25,
                    width: obstacleWidth,
                    height: obstacleHeight,
                    tilt: tiltAngle,
                    color: '#8b5cf6',
                    type: 'tilted'
                });
            }
        }

        // 파티클 생성
        function createParticles(x, y, color) {
            for (let i = 0; i < 8; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    life: 30,
                    maxLife: 30,
                    color: color
                });
            }
        }

        // 실시간 순위 목록 업데이트
        function updateRankingList() {
            rankingList.innerHTML = '';
            
            finishOrder.forEach((result, index) => {
                const rankItem = document.createElement('div');
                rankItem.className = 'flex items-center justify-between text-xs py-1 px-2 rounded';
                
                // 순위별 배경색
                if (result.rank === 1) {
                    rankItem.className += ' bg-yellow-100 border border-yellow-300';
                } else if (result.rank === 2) {
                    rankItem.className += ' bg-gray-100 border border-gray-300';
                } else if (result.rank === 3) {
                    rankItem.className += ' bg-orange-100 border border-orange-300';
                } else {
                    rankItem.className += ' bg-blue-50 border border-blue-200';
                }
                
                const medal = result.rank === 1 ? '🥇' : result.rank === 2 ? '🥈' : result.rank === 3 ? '🥉' : '🏃';
                
                rankItem.innerHTML = `
                    <div class="flex items-center">
                        <span class="mr-1">${medal}</span>
                        <span class="font-semibold">${result.rank}위</span>
                    </div>
                    <div class="text-right">
                        <div class="font-medium">캐릭터 ${result.id}</div>
                        <div class="text-gray-600">${(result.time/1000).toFixed(1)}초</div>
                    </div>
                `;
                
                rankingList.appendChild(rankItem);
            });
        }

        // 충돌 감지
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        // 장애물과 충돌 처리
        function handleObstacleCollision(player, obstacle) {
            // 충돌 방향 계산
            const playerCenterX = player.x + player.width / 2;
            const playerCenterY = player.y + player.height / 2;
            const obstacleCenterX = obstacle.x + obstacle.width / 2;
            const obstacleCenterY = obstacle.y + obstacle.height / 2;
            
            const dx = playerCenterX - obstacleCenterX;
            const dy = playerCenterY - obstacleCenterY;
            
            // 튕기는 힘 적용
            const bounceForce = 1.5;
            player.vx += (dx / Math.abs(dx || 1)) * bounceForce;
            player.vy -= bounceForce;
            
            // 속도 제한
            player.vx = Math.max(-4, Math.min(4, player.vx));
            player.vy = Math.max(-3, player.vy);
        }

        // 게임 초기화
        function initGame() {
            const characterCount = parseInt(document.getElementById('characterCount').value) || 1;
            createPlayers(characterCount);
            obstacles.length = 0;
            particles.length = 0;
            camera.y = 0;
            finishOrder = [];
            gameStartTime = Date.now();
            
            // UI 업데이트
            totalCountElement.textContent = characterCount;
            finishedCountElement.textContent = '0';
            
            // 장애물 생성 (바닥까지의 경로)
            for (let i = 0; i < 30; i++) {
                createObstacle(150 + i * 80);
            }
        }

        // 게임 업데이트
        function updateGame() {
            if (gameState !== 'playing') return;
            
            let alivePlayers = players.filter(p => p.alive);
            
            // 모든 살아있는 플레이어 업데이트
            for (let player of alivePlayers) {
                // 플레이어 이동
                if (keys.left) player.vx = Math.max(player.vx - 0.25, -2.5);
                if (keys.right) player.vx = Math.min(player.vx + 0.25, 2.5);
                
                // 중력 적용
                player.vy += 0.1;
                
                // 마찰력
                player.vx *= 0.95;
                
                // 플레이어 위치 업데이트
                player.x += player.vx;
                player.y += player.vy;
                
                // 화면 경계 처리
                if (player.x < 0) player.x = 0;
                if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
                
                // 장애물과 충돌 검사
                for (let obstacle of obstacles) {
                    if (checkCollision(player, obstacle)) {
                        handleObstacleCollision(player, obstacle);
                        createParticles(player.x + player.width/2, player.y + player.height/2, player.color);
                    }
                }
                
                // 골인 체크 (바닥에 도착)
                if (player.y >= FINISH_LINE_Y && !player.finished) {
                    player.finished = true;
                    player.finishTime = Date.now() - gameStartTime;
                    finishOrder.push({
                        rank: finishOrder.length + 1,
                        name: player.name,
                        id: player.id,
                        time: player.finishTime
                    });
                    createParticles(player.x + player.width/2, player.y + player.height/2, '#4ade80');
                    
                    // UI 업데이트
                    finishedCountElement.textContent = finishOrder.length;
                    updateRankingList();
                }
            }
            
            // 카메라 업데이트 (가장 앞선 캐릭터 기준)
            let frontPlayer = alivePlayers.reduce((front, current) => 
                current.y > front.y ? current : front, alivePlayers[0]);
            camera.y = frontPlayer.y - 200;
            
            // 승리 조건 (모든 캐릭터가 골인)
            if (finishOrder.length === players.length) {
                gameState = 'win';
                let resultText = `🏁 경주 완료!\n\n🏆 최종 순위:\n`;
                finishOrder.forEach(result => {
                    const medal = result.rank === 1 ? '🥇' : result.rank === 2 ? '🥈' : result.rank === 3 ? '🥉' : '🏃';
                    resultText += `${medal} ${result.rank}위: ${result.name} (${(result.time/1000).toFixed(1)}초)\n`;
                });
                gameMessage.innerHTML = resultText.replace(/\n/g, '<br>');
                gameOverlay.classList.remove('hidden');
                rankingDisplay.classList.add('hidden');
                showGameOver();
                return;
            }
            
            // 파티클 업데이트
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vy += 0.1; // 중력
                particle.life--;
                
                if (particle.life <= 0) {
                    particles.splice(i, 1);
                }
            }
            

        }

        // 게임 렌더링
        function renderGame() {
            // 배경 클리어
            ctx.fillStyle = '#87ceeb';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 구름 효과
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            for (let i = 0; i < 5; i++) {
                const cloudY = 100 + i * 80 - camera.y;
                if (cloudY > -50 && cloudY < canvas.height + 50) {
                    ctx.beginPath();
                    ctx.arc(50 + i * 80, cloudY, 25, 0, Math.PI * 2);
                    ctx.arc(80 + i * 80, cloudY, 35, 0, Math.PI * 2);
                    ctx.arc(110 + i * 80, cloudY, 25, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // 바닥 렌더링
            const floorY = FINISH_LINE_Y - camera.y;
            if (floorY > -100 && floorY < canvas.height + 100) {
                // 바닥 그라디언트
                const floorGradient = ctx.createLinearGradient(0, floorY - 20, 0, floorY + 50);
                floorGradient.addColorStop(0, '#8B4513');
                floorGradient.addColorStop(0.3, '#A0522D');
                floorGradient.addColorStop(1, '#654321');
                
                ctx.fillStyle = floorGradient;
                ctx.fillRect(0, floorY, canvas.width, 100);
                
                // 골인선
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(0, floorY - 5, canvas.width, 10);
                
                // 체크무늬 패턴
                ctx.fillStyle = '#000000';
                for (let i = 0; i < canvas.width; i += 20) {
                    if (Math.floor(i / 20) % 2 === 0) {
                        ctx.fillRect(i, floorY - 5, 10, 10);
                    } else {
                        ctx.fillRect(i + 10, floorY + 5, 10, 10);
                    }
                }
                
                // 골인 텍스트
                ctx.fillStyle = '#ffffff';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 3;
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.strokeText('🏁 FINISH LINE 🏁', canvas.width/2, floorY - 15);
                ctx.fillText('🏁 FINISH LINE 🏁', canvas.width/2, floorY - 15);
            }
            
            // 장애물 렌더링 (기울어진 형태)
            for (let obstacle of obstacles) {
                const obstacleY = obstacle.y - camera.y;
                if (obstacleY > -50 && obstacleY < canvas.height + 50) {
                    ctx.save();
                    
                    if (obstacle.type === 'tilted') {
                        // 기울어진 장애물 렌더링
                        const centerX = obstacle.x + obstacle.width / 2;
                        const centerY = obstacleY + obstacle.height / 2;
                        
                        ctx.translate(centerX, centerY);
                        ctx.rotate(obstacle.tilt);
                        
                        // 장애물 본체
                        ctx.fillStyle = obstacle.color;
                        ctx.fillRect(-obstacle.width/2, -obstacle.height/2, obstacle.width, obstacle.height);
                        
                        // 장애물 하이라이트
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.fillRect(-obstacle.width/2, -obstacle.height/2, obstacle.width, 5);
                        
                        // 그라디언트 효과
                        const gradient = ctx.createLinearGradient(-obstacle.width/2, -obstacle.height/2, -obstacle.width/2, obstacle.height/2);
                        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.2)');
                        gradient.addColorStop(1, 'rgba(0, 0, 0, 0.2)');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(-obstacle.width/2, -obstacle.height/2, obstacle.width, obstacle.height);
                    } else {
                        // 일반 장애물
                        ctx.fillStyle = obstacle.color;
                        ctx.fillRect(obstacle.x, obstacleY, obstacle.width, obstacle.height);
                        
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.fillRect(obstacle.x, obstacleY, obstacle.width, 5);
                    }
                    
                    ctx.restore();
                }
            }
            
            // 플레이어들 렌더링 (귀여운 캐릭터들)
            for (let player of players) {
                if (!player.alive) continue;
                
                const playerScreenY = player.y - camera.y;
                
                // 화면에 보이는 캐릭터만 렌더링
                if (playerScreenY < -50 || playerScreenY > canvas.height + 50) continue;
                
                // 그림자
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.beginPath();
                ctx.ellipse(player.x + player.width/2, playerScreenY + player.height + 5, player.width/2, 5, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // 캐릭터 몸체
                ctx.fillStyle = player.color;
                ctx.beginPath();
                ctx.arc(player.x + player.width/2, playerScreenY + player.height/2, player.width/2, 0, Math.PI * 2);
                ctx.fill();
                
                // 눈
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(player.x + 8, playerScreenY + 8, 4, 0, Math.PI * 2);
                ctx.arc(player.x + 22, playerScreenY + 8, 4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(player.x + 8, playerScreenY + 8, 2, 0, Math.PI * 2);
                ctx.arc(player.x + 22, playerScreenY + 8, 2, 0, Math.PI * 2);
                ctx.fill();
                
                // 입
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(player.x + player.width/2, playerScreenY + 18, 6, 0, Math.PI);
                ctx.stroke();
                
                // 캐릭터 번호 표시
                ctx.fillStyle = '#ffffff';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.strokeText(player.id.toString(), player.x + player.width/2, playerScreenY - 5);
                ctx.fillText(player.id.toString(), player.x + player.width/2, playerScreenY - 5);
            }
            
            // 파티클 렌더링
            for (let particle of particles) {
                const particleScreenY = particle.y - camera.y;
                const alpha = particle.life / particle.maxLife;
                ctx.fillStyle = particle.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                ctx.beginPath();
                ctx.arc(particle.x, particleScreenY, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // 게임 루프
        function gameLoop() {
            updateGame();
            renderGame();
            animationId = requestAnimationFrame(gameLoop);
        }

        // 게임 시작
        function startGame() {
            initGame();
            gameState = 'playing';
            gameOverlay.classList.add('hidden');
            rankingDisplay.classList.add('hidden');
            liveRanking.classList.remove('hidden');
            document.getElementById('characterSettings').style.display = 'none';
            updateRankingList(); // 빈 목록으로 초기화
            gameLoop();
        }

        // 게임 종료 시 설정 다시 보이기
        function showGameOver() {
            document.getElementById('characterSettings').style.display = 'block';
            liveRanking.classList.add('hidden');
        }

        // 이벤트 리스너
        gameButton.addEventListener('click', startGame);

        document.addEventListener('keydown', (e) => {
            if (e.code === 'ArrowLeft') {
                keys.left = true;
                e.preventDefault();
            }
            if (e.code === 'ArrowRight') {
                keys.right = true;
                e.preventDefault();
            }
            if (e.code === 'Space' && gameState !== 'playing') {
                startGame();
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'ArrowLeft') keys.left = false;
            if (e.code === 'ArrowRight') keys.right = false;
        });

        // Element SDK 설정
        async function render(config) {
            const gameTitle = document.getElementById('game-title');
            const buttonText = document.getElementById('button-text');
            
            gameTitle.textContent = config.game_title || defaultConfig.game_title;
            
            if (gameState === 'menu') {
                buttonText.textContent = config.start_button_text || defaultConfig.start_button_text;
            } else {
                buttonText.textContent = config.restart_button_text || defaultConfig.restart_button_text;
            }
        }

        function mapToCapabilities(config) {
            return {
                recolorables: [],
                borderables: [],
                fontEditable: undefined,
                fontSizeable: undefined
            };
        }

        function mapToEditPanelValues(config) {
            return new Map([
                ["game_title", config.game_title || defaultConfig.game_title],
                ["start_button_text", config.start_button_text || defaultConfig.start_button_text],
                ["restart_button_text", config.restart_button_text || defaultConfig.restart_button_text]
            ]);
        }

        // SDK 초기화
        if (window.elementSdk) {
            window.elementSdk.init({
                defaultConfig,
                render,
                mapToCapabilities,
                mapToEditPanelValues
            });
        }

        // 초기 렌더링
        renderGame();
    </script>
 <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'990eb5f9548fe9fc',t:'MTc2MDg2MDUwMi4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>